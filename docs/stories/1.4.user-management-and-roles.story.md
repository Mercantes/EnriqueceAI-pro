# Story 1.4: User Management & Roles

## Status

**Ready**

## Complexity Estimate

**L (Large)** — Invite flow com complexidade do trigger handle_new_user(), verificação de limites de plano, role-based page access, accept-invite flow.

## Risks

- **R1:** Trigger `handle_new_user()` cria org duplicada para convidados — requer lógica de cleanup (Opção B documentada nos Dev Notes)
- **R2:** `inviteUserByEmail()` requer service_role key — pode necessitar Edge Function ou alternativa (signInWithOtp)
- **R3:** Limites de membros dependem de seed data (plano starter) estar presente

## Executor Assignment

executor: "@dev"
quality_gate: "@architect"
quality_gate_tools: ["typecheck", "lint", "test", "build"]

## Story

**As a** manager,
**I want** to invite SDRs to my organization and manage their access,
**so that** my team can use the platform with appropriate permissions.

## Acceptance Criteria

1. Dois roles implementados: `manager` (gerente) e `sdr` (vendedor)
2. O criador da organização recebe automaticamente o role `manager`
3. Tela de gestão de usuários acessível apenas por `manager`
4. Funcionalidade de convite por email (envio de invite link via Supabase)
5. Modelo base: 3 SDRs + 1 gerente incluídos — validação de limite no backend
6. Ao exceder o limite, exibir mensagem informando necessidade de upgrade (placeholder para billing)
7. Lista de membros com status (ativo, pendente, desativado)
8. Manager pode desativar/reativar um membro
9. RLS policies para role-based access (manager vê tudo da org, SDR vê dados da org) _(MVP: ambos roles vêem dados da org via RLS org_id; filtro por created_by será implementado em stories futuras)_
10. Testes para permissões por role

## CodeRabbit Integration

> **CodeRabbit Integration**: Disabled
>
> CodeRabbit CLI is not enabled in `core-config.yaml`.
> Quality validation will use manual review process only.
> To enable, set `coderabbit_integration.enabled: true` in core-config.yaml

## Tasks / Subtasks

- [ ] **Task 1: Criar Zod schemas para gestão de membros** (AC: 4, 8)
  - [ ] 1.1 Criar `src/features/auth/schemas/member.schemas.ts`:
    - `inviteMemberSchema`: email (valid format), role (`'manager'` | `'sdr'`)
    - `updateMemberStatusSchema`: memberId (UUID), status (`'active'` | `'suspended'`)
    - `updateMemberRoleSchema`: memberId (UUID), role (`'manager'` | `'sdr'`)
  - [ ] 1.2 Exportar tipos inferidos: `InviteMemberInput`, `UpdateMemberStatusInput`, `UpdateMemberRoleInput`
  - [ ] 1.3 Testes unitários em `src/features/auth/schemas/member.schemas.test.ts`

- [ ] **Task 2: Implementar Server Actions de gestão de membros** (AC: 4, 5, 6, 8)
  - [ ] 2.1 Criar `src/features/auth/actions/invite-member.ts`:
    - Server Action `inviteMember(formData: FormData): Promise<ActionResult<void>>`
    - `requireManager()` — apenas managers podem convidar
    - Validar input com `inviteMemberSchema`
    - **Verificar limite de membros:**
      - Buscar subscription da org → plan → `included_users`
      - Contar membros ativos + invited
      - Se `count >= included_users` → retornar erro com código `MEMBER_LIMIT_REACHED`
    - Chamar `supabase.auth.admin.inviteUserByEmail(email)` (requer Edge Function ou Supabase Admin)
    - **ALTERNATIVA para MVP:** Usar `supabase.auth.signInWithOtp({ email })` para enviar magic link como convite
    - Inserir registro em `organization_members` com `status='invited'`
  - [ ] 2.2 Criar `src/features/auth/actions/update-member-status.ts`:
    - Server Action `updateMemberStatus(formData: FormData): Promise<ActionResult<void>>`
    - `requireManager()`
    - Validar: não permitir desativar a si mesmo
    - Validar: não permitir desativar o owner
    - Update `status` em `organization_members`
  - [ ] 2.3 Criar `src/features/auth/actions/update-member-role.ts`:
    - Server Action `updateMemberRole(formData: FormData): Promise<ActionResult<void>>`
    - `requireManager()`
    - Validar: não permitir alterar role do owner
    - Update `role` em `organization_members`
  - [ ] 2.4 Testes unitários para cada action

- [ ] **Task 3: Implementar verificação de limite de membros** (AC: 5, 6)
  - [ ] 3.1 Criar `src/features/auth/services/member-limits.service.ts`:
    ```typescript
    export async function checkMemberLimit(supabase: SupabaseClient, orgId: string): Promise<{
      allowed: boolean;
      current: number;
      max: number;
    }>
    ```
    - Buscar `subscriptions` join `plans` para a org
    - Contar membros (`active` + `invited`) em `organization_members`
    - Comparar com `plans.included_users`
  - [ ] 3.2 Testes unitários em `member-limits.service.test.ts`

- [ ] **Task 4: Criar tela de gestão de usuários** (AC: 3, 7, 8)
  - [ ] 4.1 Criar `src/app/(app)/settings/users/page.tsx` (Server Component):
    - Chamar `requireManager()` — apenas managers acessam
    - Buscar membros da org via Server Client
    - Renderizar `<UserManagement />`
  - [ ] 4.2 Criar `src/features/auth/components/UserManagement.tsx` (`'use client'`):
    - Cabeçalho com contagem "Membros (3/4)" e botão "Convidar membro"
    - Lista/tabela de membros com colunas:
      - Nome/Email | Role | Status | Ações
    - Status badges coloridos: `active` (verde), `invited` (amarelo), `suspended` (vermelho)
    - Dropdown de ações por membro: Alterar role, Desativar/Reativar
    - Proteção: não exibir ações para o owner da org
  - [ ] 4.3 Criar `src/features/auth/components/InviteMemberDialog.tsx` (`'use client'`):
    - Dialog (shadcn/ui) com form: email + role selector
    - Validação com Zod resolver
    - Exibir mensagem de limite quando `MEMBER_LIMIT_REACHED`:
      - "Limite de membros atingido. Faça upgrade do plano para adicionar mais membros."
      - Botão "Ver planos" (link para /settings/billing)
    - Loading state e toast de sucesso/erro
  - [ ] 4.4 Testes de componentes

- [ ] **Task 5: Implementar RLS role-based para dados de SDR** (AC: 9)
  - [ ] 5.1 **NOTA:** As RLS policies base já existem na migration inicial. Leads, cadences e templates já são filtrados por `org_id = auth.user_org_id()` — todos membros da org vêem os mesmos dados
  - [ ] 5.2 Para MVP: SDR vê TODOS os leads/cadences da org (mesmo design da RLS atual). Filtro por `created_by = auth.uid()` será implementado em stories futuras quando necessário
  - [ ] 5.3 O role-based access nesta story é focado em **pages**, não em RLS de dados:
    - Manager: acessa Settings, Users Management, Integrations
    - SDR: acessa Dashboard, Leads, Cadences, Templates
  - [ ] 5.4 Criar `src/lib/auth/permissions.ts`:
    ```typescript
    export const MANAGER_ONLY_PATHS = [
      '/settings/users',
      '/settings/integrations',
      '/settings/billing',
    ];

    export function canAccessPath(role: MemberRole, path: string): boolean {
      if (role === 'manager') return true;
      return !MANAGER_ONLY_PATHS.some(p => path.startsWith(p));
    }
    ```
  - [ ] 5.5 Usar `requireManager()` nas pages restritas (já existente de Story 1.2)

- [ ] **Task 6: Handle invite acceptance flow** (AC: 4)
  - [ ] 6.1 Quando um convidado clica no link de invite e se registra, precisa ser vinculado à org
  - [ ] 6.2 Criar `src/features/auth/actions/accept-invite.ts`:
    - Server Action que atualiza `organization_members.status` de `'invited'` para `'active'`
    - Setar `accepted_at = now()`
  - [ ] 6.3 **NOTA:** O trigger `handle_new_user()` cria uma NOVA org para qualquer user novo. Para convidados, será necessário:
    - Opção A: Modificar o trigger para verificar se o email já tem invite pendente (requer nova migration)
    - Opção B: Após signup, o accept-invite action deleta a org auto-criada e vincula à org convidada
    - **Decisão: usar Opção B para MVP** — mais simples, sem alterar migration
  - [ ] 6.4 Implementar lógica em `accept-invite.ts`:
    - Buscar invite pendente pelo email do user logado
    - Se existe invite: deletar org auto-criada, atualizar member status para 'active'
    - Se não existe invite: manter org auto-criada (signup normal)
  - [ ] 6.5 Chamar `accept-invite` no primeiro login do usuário (verificar em `useAuth` ou no layout)

- [ ] **Task 7: Atualizar auth.contract.ts** (AC: 1-9)
  - [ ] 7.1 Adicionar ao contrato:
    ```typescript
    inviteMember(data: InviteMemberInput): Promise<ActionResult<void>>;
    updateMemberStatus(data: UpdateMemberStatusInput): Promise<ActionResult<void>>;
    updateMemberRole(data: UpdateMemberRoleInput): Promise<ActionResult<void>>;
    getOrgMembers(): Promise<OrganizationMember[]>;
    checkMemberLimit(): Promise<{ allowed: boolean; current: number; max: number }>;
    ```
  - [ ] 7.2 Atualizar barrel export

- [ ] **Task 8: Testes de permissões por role** (AC: 10)
  - [ ] 8.1 Testes de integração em `tests/integration/role-permissions.test.ts`:
    - Manager pode convidar membros
    - SDR não pode convidar membros (requireManager rejeita)
    - Manager pode desativar membro
    - SDR não pode desativar membro
    - Manager pode acessar /settings/users
    - SDR é redirecionado ao tentar acessar /settings/users
  - [ ] 8.2 Testes de componente:
    - UserManagement exibe membros corretamente
    - InviteMemberDialog exibe mensagem de limite quando atingido
    - Status badges corretos por status
  - [ ] 8.3 Testes de service:
    - `checkMemberLimit` retorna correto para org no limite e abaixo

- [ ] **Task 9: Validação final**
  - [ ] 9.1 `pnpm lint` — sem erros
  - [ ] 9.2 `pnpm typecheck` — sem erros
  - [ ] 9.3 `pnpm test:run` — todos os testes passando
  - [ ] 9.4 `pnpm build` — build sem erros
  - [ ] 9.5 Testar fluxo: login como manager → settings/users → convidar membro → ver na lista
  - [ ] 9.6 Testar limite: convidar 4° membro em plano starter (4 users) → ver mensagem de upgrade
  - [ ] 9.7 Testar desativar/reativar membro

## Dev Notes

### Architecture Context

**[Source: architecture.md#8.4-authentication-workflow]**

O fluxo de convite de membros:
```
Manager → Invite form → inviteMember Server Action
  → Check member limit (plan.included_users)
  → supabase.auth.inviteUserByEmail() ou signInWithOtp()
  → INSERT organization_members (status='invited')
  → Email enviado ao convidado
  → Convidado clica no link → signup → accept-invite
```

### Database Schema (Já Existente)

**[Source: supabase/migrations/20260219_000001_initial_schema.sql]**

```sql
-- member_role enum: 'manager' | 'sdr'
-- member_status enum: 'invited' | 'active' | 'suspended' | 'removed'

CREATE TABLE organization_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  role member_role NOT NULL DEFAULT 'sdr',
  status member_status NOT NULL DEFAULT 'invited',
  invited_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  accepted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(org_id, user_id)
);

-- Plans table (para verificar member limit)
CREATE TABLE plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  included_users INTEGER NOT NULL DEFAULT 4,
  -- ... other columns
);

-- Subscriptions (1 por org)
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  plan_id UUID REFERENCES plans(id) NOT NULL,
  status subscription_status NOT NULL DEFAULT 'trialing',
  -- ...
  UNIQUE(org_id)
);
```

**Seed data (starter plan):**
```sql
INSERT INTO plans (name, slug, price_cents, max_leads, max_ai_per_day,
  max_whatsapp_per_month, included_users, additional_user_price_cents, features)
VALUES
  ('Starter', 'starter', 0, 500, 20, 200, 4, 2900, '{"enrichment":true}'),
  -- ...
```

**Modelo base: 4 users incluídos (1 manager + 3 SDRs) no plano Starter.**

### Auth Actions API

**[Source: architecture.md#5-api-specification]**

| Action | Signature | Description |
|--------|-----------|-------------|
| `inviteMember` | `(data: InviteInput) => ActionResult<Invite>` | Invite user to org |
| `updateMemberRole` | `(memberId: string, role: MemberRole) => ActionResult<Member>` | Change member role |
| `deactivateMember` | `(memberId: string) => ActionResult<void>` | Disable member access |

### RLS Policies para Members (Já Existentes)

**[Source: supabase/migrations/20260219_000001_initial_schema.sql]**

```sql
-- Members: org members can read, only managers can write
CREATE POLICY "members_org_read" ON organization_members FOR SELECT
  USING (org_id = auth.user_org_id());
CREATE POLICY "members_manager_insert" ON organization_members FOR INSERT
  WITH CHECK (org_id = auth.user_org_id() AND auth.is_manager());
CREATE POLICY "members_manager_update" ON organization_members FOR UPDATE
  USING (org_id = auth.user_org_id() AND auth.is_manager());
CREATE POLICY "members_manager_delete" ON organization_members FOR DELETE
  USING (org_id = auth.user_org_id() AND auth.is_manager());
```

### Invite Flow Considerations

**Problema do trigger handle_new_user():**

O trigger cria uma org nova para QUALQUER user que se registra. Quando um convidado faz signup, ele vai ganhar uma org própria além da org que o convidou.

**Solução MVP (Opção B):**
1. Convidado recebe email → clica no link → se registra normalmente
2. Trigger `handle_new_user()` cria org temporária
3. Na primeira vez que o app carrega (layout ou useAuth), verificar se existe invite pendente
4. Se sim: deletar org auto-criada + atualizar member status para 'active'
5. Se não: manter fluxo normal (signup regular)

```typescript
// src/features/auth/actions/accept-invite.ts
'use server';

export async function acceptPendingInvite(): Promise<ActionResult<{ orgId: string } | null>> {
  const supabase = await createServerSupabaseClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { success: false, error: 'Not authenticated' };

  // Check for pending invite
  const { data: invite } = await supabase
    .from('organization_members')
    .select('*, organization:organizations(*)')
    .eq('user_id', user.id)
    .eq('status', 'invited')
    .single();

  if (!invite) return { success: true, data: null }; // No invite, normal signup

  // Delete auto-created org (the one from handle_new_user trigger)
  // The user's "own" org is where they are manager
  const { data: autoOrg } = await supabase
    .from('organization_members')
    .select('org_id')
    .eq('user_id', user.id)
    .eq('role', 'manager')
    .eq('status', 'active')
    .single();

  if (autoOrg && autoOrg.org_id !== invite.org_id) {
    // Use admin client or RPC to delete auto-created org
    // This cascades: deletes members, subscriptions, etc.
  }

  // Accept the invite
  await supabase
    .from('organization_members')
    .update({ status: 'active', accepted_at: new Date().toISOString() })
    .eq('id', invite.id);

  return { success: true, data: { orgId: invite.org_id } };
}
```

### Page Protection Pattern

**[Source: architecture.md#10-frontend-architecture, #15-security]**

```typescript
// Settings/Users page - manager only
// src/app/(app)/settings/users/page.tsx
import { requireManager } from '@/lib/auth/require-manager';

export default async function UsersPage() {
  await requireManager(); // Redirect SDRs to /dashboard
  // ... render page
}
```

### Coding Standards

**[Source: architecture.md#17-coding-standards]**

1. **Contract Pattern:** Todas novas funções expostas via `auth.contract.ts`
2. **ActionResult<T>:** Todas mutations retornam esse tipo
3. **requireManager():** Gate de acesso para pages e actions de manager
4. **Zod at Boundaries:** Validar TODOS inputs de forms
5. **`'use client'` apenas onde necessário:** Pages são Server, forms são Client

### Dependencies (Stories Anteriores)

- Story 1.1: Projeto configurado, shadcn/ui, Vitest ✅
- Story 1.2: Auth flow, requireAuth(), requireManager(), useAuth hook ✅
- Story 1.3: OrganizationContext, useOrganization hook, settings page ✅

### Testing

**[Source: architecture.md#16-testing-strategy]**

- **Unit Tests:** Schemas, services (member-limits), actions
- **Component Tests:** UserManagement, InviteMemberDialog
- **Integration Tests:** Role-based permissions com Supabase local
- **Coverage target:** 70%+ overall, 90%+ services

**Pattern para testar Server Actions com requireManager():**

```typescript
// Mock requireManager to simulate manager user
vi.mock('@/lib/auth/require-manager', () => ({
  requireManager: vi.fn().mockResolvedValue({
    id: 'manager-user-id',
    email: 'manager@test.com',
  }),
}));

// Mock requireManager to simulate unauthorized (SDR)
vi.mock('@/lib/auth/require-manager', () => ({
  requireManager: vi.fn().mockImplementation(() => {
    redirect('/dashboard'); // Simula redirect
  }),
}));
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-19 | 1.0 | Story criada a partir do Epic 1 | River (SM) |
| 2026-02-19 | 1.1 | Validação GO (7/10). Fix SF-2: AC 9 corrigido (escopo MVP clarificado). Adicionados: Complexity, Risks. Status Draft → Ready | Pax (PO) |

## Dev Agent Record

### Agent Model Used

_(To be filled by dev agent)_

### Debug Log References

_(To be filled by dev agent)_

### Completion Notes List

_(To be filled by dev agent)_

### File List

_(To be filled by dev agent)_

## QA Results

_(To be filled by QA agent)_
