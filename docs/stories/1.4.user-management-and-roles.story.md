# Story 1.4: User Management & Roles

## Status

**Done**

## Complexity Estimate

**L (Large)** — Invite flow com complexidade do trigger handle_new_user(), verificação de limites de plano, role-based page access, accept-invite flow.

## Risks

- **R1:** Trigger `handle_new_user()` cria org duplicada para convidados — requer lógica de cleanup (Opção B documentada nos Dev Notes)
- **R2:** `inviteUserByEmail()` requer service_role key — pode necessitar Edge Function ou alternativa (signInWithOtp)
- **R3:** Limites de membros dependem de seed data (plano starter) estar presente

## Executor Assignment

executor: "@dev"
quality_gate: "@architect"
quality_gate_tools: ["typecheck", "lint", "test", "build"]

## Story

**As a** manager,
**I want** to invite SDRs to my organization and manage their access,
**so that** my team can use the platform with appropriate permissions.

## Acceptance Criteria

1. Dois roles implementados: `manager` (gerente) e `sdr` (vendedor)
2. O criador da organização recebe automaticamente o role `manager`
3. Tela de gestão de usuários acessível apenas por `manager`
4. Funcionalidade de convite por email (envio de invite link via Supabase)
5. Modelo base: 3 SDRs + 1 gerente incluídos — validação de limite no backend
6. Ao exceder o limite, exibir mensagem informando necessidade de upgrade (placeholder para billing)
7. Lista de membros com status (ativo, pendente, desativado)
8. Manager pode desativar/reativar um membro
9. RLS policies para role-based access (manager vê tudo da org, SDR vê dados da org) _(MVP: ambos roles vêem dados da org via RLS org_id; filtro por created_by será implementado em stories futuras)_
10. Testes para permissões por role

## CodeRabbit Integration

> **CodeRabbit Integration**: Disabled
>
> CodeRabbit CLI is not enabled in `core-config.yaml`.
> Quality validation will use manual review process only.
> To enable, set `coderabbit_integration.enabled: true` in core-config.yaml

## Tasks / Subtasks

- [x] **Task 1: Criar Zod schemas para gestão de membros** (AC: 4, 8)
  - [x] 1.1 Criar `src/features/auth/schemas/member.schemas.ts`
  - [x] 1.2 Exportar tipos inferidos
  - [x] 1.3 Testes unitários em `member.schemas.test.ts` (7 testes)

- [x] **Task 2: Implementar Server Actions de gestão de membros** (AC: 4, 5, 6, 8)
  - [x] 2.1 `invite-member.ts` com requireManager, limit check, OTP invite
  - [x] 2.2 `update-member-status.ts` com proteção owner/self
  - [x] 2.3 `update-member-role.ts` com proteção owner
  - [x] 2.4 Testes unitários para cada action (10 testes)

- [x] **Task 3: Implementar verificação de limite de membros** (AC: 5, 6)
  - [x] 3.1 `member-limits.service.ts` com query subscription→plan
  - [x] 3.2 Testes unitários (3 testes)

- [x] **Task 4: Criar tela de gestão de usuários** (AC: 3, 7, 8)
  - [x] 4.1 `settings/users/page.tsx` com requireManager
  - [x] 4.2 `UserManagement.tsx` com status badges, ações protegidas
  - [x] 4.3 `InviteMemberDialog.tsx` com mensagem de limite
  - [x] 4.4 Testes de componentes

- [x] **Task 5: Implementar RLS role-based para dados de SDR** (AC: 9)
  - [x] 5.1-5.3 RLS base por org_id (MVP)
  - [x] 5.4 `permissions.ts` com MANAGER_ONLY_PATHS e canAccessPath
  - [x] 5.5 requireManager() nas pages restritas

- [x] **Task 6: Handle invite acceptance flow** (AC: 4)
  - [x] 6.1-6.5 `accept-invite.ts` com Opção B (delete org auto-criada)

- [x] **Task 7: Atualizar auth.contract.ts** (AC: 1-9)
  - [x] 7.1-7.2 Contract e barrel export atualizados

- [x] **Task 8: Testes de permissões por role** (AC: 10)
  - [x] 8.1 Testes de permissões (4 testes)
  - [x] 8.2-8.3 Testes de service e schemas

- [x] **Task 9: Validação final**
  - [x] 9.1 lint — sem erros
  - [x] 9.2 typecheck — sem erros
  - [x] 9.3 test — 537 testes passando
  - [x] 9.4-9.7 Fluxos validados

## Dev Notes

### Architecture Context

**[Source: architecture.md#8.4-authentication-workflow]**

O fluxo de convite de membros:
```
Manager → Invite form → inviteMember Server Action
  → Check member limit (plan.included_users)
  → supabase.auth.inviteUserByEmail() ou signInWithOtp()
  → INSERT organization_members (status='invited')
  → Email enviado ao convidado
  → Convidado clica no link → signup → accept-invite
```

### Database Schema (Já Existente)

**[Source: supabase/migrations/20260219_000001_initial_schema.sql]**

```sql
-- member_role enum: 'manager' | 'sdr'
-- member_status enum: 'invited' | 'active' | 'suspended' | 'removed'

CREATE TABLE organization_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  role member_role NOT NULL DEFAULT 'sdr',
  status member_status NOT NULL DEFAULT 'invited',
  invited_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  accepted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE(org_id, user_id)
);

-- Plans table (para verificar member limit)
CREATE TABLE plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  slug TEXT UNIQUE NOT NULL,
  included_users INTEGER NOT NULL DEFAULT 4,
  -- ... other columns
);

-- Subscriptions (1 por org)
CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  org_id UUID REFERENCES organizations(id) ON DELETE CASCADE NOT NULL,
  plan_id UUID REFERENCES plans(id) NOT NULL,
  status subscription_status NOT NULL DEFAULT 'trialing',
  -- ...
  UNIQUE(org_id)
);
```

**Seed data (starter plan):**
```sql
INSERT INTO plans (name, slug, price_cents, max_leads, max_ai_per_day,
  max_whatsapp_per_month, included_users, additional_user_price_cents, features)
VALUES
  ('Starter', 'starter', 0, 500, 20, 200, 4, 2900, '{"enrichment":true}'),
  -- ...
```

**Modelo base: 4 users incluídos (1 manager + 3 SDRs) no plano Starter.**

### Auth Actions API

**[Source: architecture.md#5-api-specification]**

| Action | Signature | Description |
|--------|-----------|-------------|
| `inviteMember` | `(data: InviteInput) => ActionResult<Invite>` | Invite user to org |
| `updateMemberRole` | `(memberId: string, role: MemberRole) => ActionResult<Member>` | Change member role |
| `deactivateMember` | `(memberId: string) => ActionResult<void>` | Disable member access |

### RLS Policies para Members (Já Existentes)

**[Source: supabase/migrations/20260219_000001_initial_schema.sql]**

```sql
-- Members: org members can read, only managers can write
CREATE POLICY "members_org_read" ON organization_members FOR SELECT
  USING (org_id = auth.user_org_id());
CREATE POLICY "members_manager_insert" ON organization_members FOR INSERT
  WITH CHECK (org_id = auth.user_org_id() AND auth.is_manager());
CREATE POLICY "members_manager_update" ON organization_members FOR UPDATE
  USING (org_id = auth.user_org_id() AND auth.is_manager());
CREATE POLICY "members_manager_delete" ON organization_members FOR DELETE
  USING (org_id = auth.user_org_id() AND auth.is_manager());
```

### Invite Flow Considerations

**Problema do trigger handle_new_user():**

O trigger cria uma org nova para QUALQUER user que se registra. Quando um convidado faz signup, ele vai ganhar uma org própria além da org que o convidou.

**Solução MVP (Opção B):**
1. Convidado recebe email → clica no link → se registra normalmente
2. Trigger `handle_new_user()` cria org temporária
3. Na primeira vez que o app carrega (layout ou useAuth), verificar se existe invite pendente
4. Se sim: deletar org auto-criada + atualizar member status para 'active'
5. Se não: manter fluxo normal (signup regular)

```typescript
// src/features/auth/actions/accept-invite.ts
'use server';

export async function acceptPendingInvite(): Promise<ActionResult<{ orgId: string } | null>> {
  const supabase = await createServerSupabaseClient();
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { success: false, error: 'Not authenticated' };

  // Check for pending invite
  const { data: invite } = await supabase
    .from('organization_members')
    .select('*, organization:organizations(*)')
    .eq('user_id', user.id)
    .eq('status', 'invited')
    .single();

  if (!invite) return { success: true, data: null }; // No invite, normal signup

  // Delete auto-created org (the one from handle_new_user trigger)
  // The user's "own" org is where they are manager
  const { data: autoOrg } = await supabase
    .from('organization_members')
    .select('org_id')
    .eq('user_id', user.id)
    .eq('role', 'manager')
    .eq('status', 'active')
    .single();

  if (autoOrg && autoOrg.org_id !== invite.org_id) {
    // Use admin client or RPC to delete auto-created org
    // This cascades: deletes members, subscriptions, etc.
  }

  // Accept the invite
  await supabase
    .from('organization_members')
    .update({ status: 'active', accepted_at: new Date().toISOString() })
    .eq('id', invite.id);

  return { success: true, data: { orgId: invite.org_id } };
}
```

### Page Protection Pattern

**[Source: architecture.md#10-frontend-architecture, #15-security]**

```typescript
// Settings/Users page - manager only
// src/app/(app)/settings/users/page.tsx
import { requireManager } from '@/lib/auth/require-manager';

export default async function UsersPage() {
  await requireManager(); // Redirect SDRs to /dashboard
  // ... render page
}
```

### Coding Standards

**[Source: architecture.md#17-coding-standards]**

1. **Contract Pattern:** Todas novas funções expostas via `auth.contract.ts`
2. **ActionResult<T>:** Todas mutations retornam esse tipo
3. **requireManager():** Gate de acesso para pages e actions de manager
4. **Zod at Boundaries:** Validar TODOS inputs de forms
5. **`'use client'` apenas onde necessário:** Pages são Server, forms são Client

### Dependencies (Stories Anteriores)

- Story 1.1: Projeto configurado, shadcn/ui, Vitest ✅
- Story 1.2: Auth flow, requireAuth(), requireManager(), useAuth hook ✅
- Story 1.3: OrganizationContext, useOrganization hook, settings page ✅

### Testing

**[Source: architecture.md#16-testing-strategy]**

- **Unit Tests:** Schemas, services (member-limits), actions
- **Component Tests:** UserManagement, InviteMemberDialog
- **Integration Tests:** Role-based permissions com Supabase local
- **Coverage target:** 70%+ overall, 90%+ services

**Pattern para testar Server Actions com requireManager():**

```typescript
// Mock requireManager to simulate manager user
vi.mock('@/lib/auth/require-manager', () => ({
  requireManager: vi.fn().mockResolvedValue({
    id: 'manager-user-id',
    email: 'manager@test.com',
  }),
}));

// Mock requireManager to simulate unauthorized (SDR)
vi.mock('@/lib/auth/require-manager', () => ({
  requireManager: vi.fn().mockImplementation(() => {
    redirect('/dashboard'); // Simula redirect
  }),
}));
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-19 | 1.0 | Story criada a partir do Epic 1 | River (SM) |
| 2026-02-19 | 1.1 | Validação GO (7/10). Fix SF-2: AC 9 corrigido (escopo MVP clarificado). Adicionados: Complexity, Risks. Status Draft → Ready | Pax (PO) |

## Dev Agent Record

### Agent Model Used

_(To be filled by dev agent)_

### Debug Log References

_(To be filled by dev agent)_

### Completion Notes List

_(To be filled by dev agent)_

### File List

_(To be filled by dev agent)_

## QA Results

_(To be filled by QA agent)_
